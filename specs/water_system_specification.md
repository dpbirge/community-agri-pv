# Water System Specification

---

## Implementation Status

### Complete

**Data files** (`data/water/`):

- `wells-toy.csv` — 38 rows, depths 10–120m, TDS 1000–8000 ppm, flow rates, capital + O&M costs
- `pump_systems-toy.csv` — 5 pump types with depth, flow rate, efficiency, motor kW, costs
- `treatment_kwh_per_m3-toy.csv` — 7 TDS bands, energy min/typical/max, recovery rate, brine ratio
- `water_treatment-research.csv` — 12 TDS bands, energy, recovery, membrane life, CAPEX/OPEX
- `storage_systems-toy.csv` — 3 types (underground tank, surface tank, reservoir), evaporation, costs
- `irrigation_systems-toy.csv` — 3 types (drip, sprinkler, furrow), efficiency, costs

**Configuration files** (`settings/`):

- `water_systems_base.yaml` — 3 wells, BWRO treatment unit, municipal source, underground storage tank
- `water_policy_base.yaml` — irrigation mode (static/dynamic), dispatch strategy, monthly caps
- `data_registry_base.yaml` — `water_supply` and `water_pricing` sections registered

**Source modules** (`src/`):

- `src/irrigation_demand.py` — fully implemented; reads farm profiles + crop growth data; outputs
  per-field ETc, demand (m3/day), and crop TDS requirements; public API: `compute_irrigation_demand`,
  `save_irrigation_demand`, `load_irrigation_demand`
- `src/crop_yield.py` — fully implemented; FAO Paper 33 water-yield response for post-simulation
  harvest prediction; used in dynamic irrigation mode

**Simulation outputs** (`simulation/`):

- `daily_irrigation_demand.csv` — generated by `src/irrigation_demand.py`; columns: day,
  per-field ETc, per-field demand (m3), per-field crop, total demand (m3), TDS requirement (ppm)

- `src/water.py` — fully implemented; daily water supply dispatch with three strategies
  (`minimize_cost`, `minimize_treatment`, `minimize_draw`), BWRO treatment with TDS-band snap,
  storage tank state, monthly cap enforcement with look-ahead; public API: `compute_water_supply`,
  `save_water_supply`, `load_water_supply`

### Not Yet Implemented

- **`size_water_system()`** — system sizing tool in `src/water.py` (see System Sizing Tool section)

---

## System Configuration Structure

The system uses `water_systems.yaml` to define one or more independent water systems. Each system contains:

- **N wells** — each with depth (m), pump type, flow rate (m3/hr), and TDS (ppm)
- **One treatment unit** — type (BWRO), throughput (m3/hr), goal output TDS (ppm); energy looked up
  by snapping input TDS to the nearest band in the treatment CSV
- **One municipal source** — cost (per m3), monthly cap (m3, optional), TDS (ppm, ~200), throughput (m3/hr)
- **Zero or one storage tank** — capacity (m3), type, max output rate (m3/hr); initial fill and TDS
  read from config

Water quality is tracked as TDS (ppm) — the single scalar quality metric.

---

## Water Flow & Blending

- Untreated well water goes directly to fields when its TDS is at or below the day's crop requirement
- Treated and untreated groundwater can be blended to hit a TDS target more cheaply than full treatment
- Three-way blending: untreated groundwater + treated groundwater + municipal water
- Treatment produces brine/reject water — tracked as lost volume, not delivered to fields
- Blended TDS is the volume-weighted average of all contributing streams

---

## Storage Tank Behavior

- Tank carries two state variables across days: fill level (m3) and blended TDS (ppm)
- When mixed-quality water enters, blended TDS is recalculated via volume-weighted mixing
- Tank state is initialized from `water_systems.yaml` (initial fill + initial TDS)
- Tank draw is limited by `max_output_rate` (m3/hr × 24 hr/day); input is limited only by sources

---

## Daily TDS Requirement

- Requirement is the minimum (strictest) `tds_no_penalty_ppm` threshold across all crops active on
  that day across all fields linked to the water system
- Three threshold levels exist in `crop_growth_params-research.csv`:
  - `tds_no_penalty_ppm` — below this, no yield reduction
  - `tds_upper_stress_ppm` — between lower and upper, yield reduces
  - `tds_lethal_ppm` — above this, crop dies
- The simulation targets `tds_no_penalty_ppm` to avoid any yield penalty; upper-stress and lethal
  thresholds are available for future stress-response extensions

---

## Pumping Energy

Formula (SI units, result in kWh):

```text
pumping_energy_kwh = (1000 × 9.81 × depth_m × volume_m3) / (pump_efficiency × 3_600_000)
```

Where 1000 kg/m³ is water density, 9.81 m/s² is gravitational acceleration, and 3,600,000 converts
joules to kWh. Use well depth as the primary head; horizontal losses are secondary and omitted for
now.

## Treatment Energy

Snap the blended input TDS to the nearest row in the treatment CSV. Use the `energy_kwh_per_m3`
(or `typical` column in the toy CSV) multiplied by treated volume to get `treatment_energy_kwh`.
Track brine volume as:

```text
brine_m3 = treated_volume_m3 × (1 - recovery_rate_pct / 100)
```

---

## Policy & Dispatch

Policy is configured in `water_policy_base.yaml`. The MVP uses rule-based priority dispatch.
Three strategies are selectable via `blending_strategy`:

- `minimize_cost` — minimize the total cost of water delivered (default)
- `minimize_treatment` — minimize volume sent through treatment (prefers direct draw + municipal)
- `minimize_draw` — minimize total groundwater extraction (prefers municipal up to cap)

### Monthly Cap Enforcement

- `look_ahead: true` (the current default) — remaining monthly cap divided evenly across the
  remaining days of the month; this daily allowance replaces the cap floor on each day
- `look_ahead: false` — enforce only a running cumulative cap (simpler, can front-load consumption)

---

## Daily Output Columns

The output DataFrame from `src/water.py` must include:

| Column | Description |
| --- | --- |
| `day` | date |
| `{well_name}_extraction_m3` | m3 drawn from each well (one col per well) |
| `{well_name}_tds_ppm` | TDS of each well (static from config) |
| `total_groundwater_m3` | total extracted across all wells |
| `treated_volume_m3` | volume sent through treatment |
| `treatment_reject_m3` | brine/reject volume lost |
| `treatment_energy_kwh` | energy consumed by treatment |
| `pumping_energy_kwh` | energy consumed by all pumps |
| `municipal_volume_m3` | municipal water used |
| `municipal_cost` | cost of municipal water |
| `groundwater_cost` | pumping + treatment cost (amortized O&M, not CAPEX) |
| `total_water_cost` | municipal + groundwater cost |
| `blended_tds_delivered_ppm` | TDS of water actually delivered to fields |
| `crop_tds_requirement_ppm` | required TDS threshold for the day (from irrigation demand) |
| `total_delivered_m3` | total water delivered to fields |
| `deficit_m3` | unmet demand when caps prevent full delivery |
| `storage_level_m3` | tank fill level at end of day |
| `storage_tds_ppm` | tank TDS at end of day |
| `total_energy_kwh` | pumping + treatment combined |

---

## System Sizing Tool

The water supply simulation (`src/water.py`) reveals whether a given configuration can meet demand.
The sizing tool inverts this: given a farm profile's demand, it recommends a system configuration
that meets demand at maximum efficiency.

### Concept

The tool takes the irrigation demand profile as a fixed input (driven by crops, field areas,
planting schedules, and weather) and selects water system components from the existing data
catalogs (`wells-toy.csv`, `pump_systems-toy.csv`, `water_treatment-research.csv`,
`storage_systems-toy.csv`) to build a configuration that eliminates deficit while optimizing a
chosen objective.

### Inputs

- `irrigation_demand_df` — from `compute_irrigation_demand()`, providing daily `total_demand_m3`
  and `crop_tds_requirement_ppm`
- Component catalogs — the CSV files in `data/water/` (wells at various depths/TDS/flow, pump
  types, treatment specs, storage types)
- Municipal source parameters — TDS, cost per m3, max throughput
- Objective — one of: `minimize_cost`, `minimize_energy`, `minimize_draw`
- Constraints — max capital budget, max number of wells, whether municipal is available

### Sizing Procedure

#### Step 1: Demand Profile Analysis

Extract key statistics from `irrigation_demand_df`:

- `peak_daily_demand_m3` — maximum of `total_demand_m3` across all days
- `avg_daily_demand_m3` — mean of `total_demand_m3` on days with nonzero demand
- `p95_daily_demand_m3` — 95th percentile daily demand (design target for well capacity)
- `peak_monthly_demand_m3` — max monthly sum, for cap sizing
- `strictest_tds_ppm` — minimum of `crop_tds_requirement_ppm` across all active days
- `consecutive_peak_days` — longest run of days where demand exceeds the 75th percentile,
  for storage buffer sizing

#### Step 2: Extraction Capacity Requirement

Treatment loses water to brine, so wells must extract more than the delivery volume. The
extraction overhead depends on blended well TDS, crop TDS requirement, and treatment recovery:

```text
f_treat = max(0, (blended_well_tds - strictest_tds) / (blended_well_tds - goal_tds))
recovery = lookup(blended_well_tds).recovery_rate_pct / 100
feed_factor = f_treat / recovery + (1 - f_treat)
min_extraction_m3_day = p95_daily_demand * feed_factor
```

`feed_factor` converts delivery m3 to extraction m3. When no treatment is needed
(`f_treat = 0`), `feed_factor = 1`. When all water must be treated at 75% recovery,
`feed_factor = 1.33`.

#### Step 3: Well Selection

From `wells-toy.csv`, build a candidate well set:

1. Sort candidate wells by depth ascending (shallower = lower TDS, lower pumping energy)
2. Add wells greedily until `sum(flow_rate_m3_day) >= min_extraction_m3_day`
3. After each addition, recompute `blended_well_tds` (flow-weighted average TDS across selected
   wells) and re-derive `feed_factor` — adding a deep high-TDS well increases the treatment
   fraction and may require another well to compensate for brine loss
4. Match each well to the cheapest pump type from `pump_systems-toy.csv` where
   `max_depth_m >= well_depth_m`

Objective modifies selection:

- `minimize_energy` — prefer shallow wells even at higher count
- `minimize_cost` — balance depth against total CAPEX (fewer deep wells may be cheaper than
  many shallow ones despite higher pumping energy)
- `minimize_draw` — size wells minimally, lean on municipal supplement

#### Step 4: Treatment Throughput

Required throughput:

```text
peak_treated_product_m3_hr = (p95_daily_demand * f_treat) / 24
peak_feed_m3_hr = peak_treated_product_m3_hr / recovery
```

Select `throughput_m3_hr` that exceeds `peak_feed_m3_hr`. Treatment type is BWRO for all TDS
ranges in the current catalogs.

#### Step 5: Storage Sizing

Storage smooths demand peaks so wells can be sized closer to average than peak demand:

- Without storage: wells must handle `peak_daily_demand * feed_factor`
- With storage: wells only need to handle a multi-day rolling average

Sizing heuristic:

```text
buffer_days = consecutive_peak_days
storage_capacity_m3 = buffer_days * (peak_daily_demand - avg_daily_demand) * feed_factor
```

Clamp to a practical range (50–2000 m3 from `storage_systems-toy.csv`). Select storage type
by objective: underground tank has lowest evaporation loss (2%/yr) but highest CAPEX; reservoir
is cheapest but loses 15%/yr.

When storage is added, re-derive `min_extraction_m3_day` using `avg_daily_demand` instead of
`p95_daily_demand`, since the tank absorbs peaks. Re-run Step 3 with the lower target.

#### Step 6: Municipal Supplement

If the objective permits municipal use:

- `monthly_municipal_m3` = gap between monthly well delivery capacity and monthly demand
- `municipal_throughput_m3_hr` = peak daily gap / 24
- If wells cover all demand, set municipal cap to zero

If the objective is `minimize_draw`, set municipal high and reduce wells accordingly.

#### Step 7: Validate via Simulation

Run `compute_water_supply()` with the recommended configuration against the full demand series.
Extract performance metrics:

| Metric | Formula |
| --- | --- |
| Deficit fraction | `sum(deficit_m3) / sum(total_demand_m3)` |
| Cost per m3 delivered | `sum(total_water_cost) / sum(total_delivered_m3)` |
| Energy per m3 delivered | `sum(total_energy_kwh) / sum(total_delivered_m3)` |
| GW fraction | `sum(total_groundwater_m3) / sum(total_delivered_m3)` |
| Municipal fraction | `sum(municipal_volume_m3) / sum(total_delivered_m3)` |
| Treatment fraction | `sum(treated_volume_m3) / sum(total_delivered_m3)` |
| Brine loss fraction | `sum(treatment_reject_m3) / sum(total_groundwater_m3)` |
| Annual CAPEX | sum of well + pump + treatment + storage capital costs |
| Annual OPEX | sum of well O&M + pump O&M + treatment maintenance + municipal cost |

If deficit fraction exceeds a threshold (default 0), iterate: add one more well or increase
storage, then re-validate. Stop when deficit is within tolerance.

### Output

The sizing tool produces:

1. **Recommended `water_systems` config** — a dict (or YAML) matching the `water_systems_base.yaml`
   schema, ready to write to a scenario file
2. **Sizing summary** — demand analysis statistics, component selections with rationale, and
   simulated performance metrics
3. **Comparison table** (optional) — when called with `compare=True`, runs three variants
   (low/medium/high investment) and returns a side-by-side DataFrame of metrics vs cost

### Module API

```python
size_water_system(irrigation_demand_df, registry_path, *,
                  objective='minimize_cost',
                  municipal_available=True,
                  max_wells=6,
                  max_capital_budget=None,
                  target_deficit_fraction=0.0,
                  root_dir=None)
```

Returns:

```python
{
    'config': { ... },         # water_systems YAML-compatible dict
    'summary': { ... },        # demand stats + component rationale + performance metrics
    'demand_analysis': { ... } # peak/avg/p95/monthly/tds stats
}
```

### Placement

This function lives in `src/water.py` alongside the simulation functions. It reuses the same
internal helpers (`_snap_tds_to_band`, `_pumping_energy_kwh`, `_blend_tds`) and calls
`compute_water_supply` internally for the validation step.

---

## Reference: `src/water.py` Architecture

`src/water.py` follows the same functional architecture as `src/energy_supply.py` and
`src/community_demand.py`.

### Simulation API

```python
compute_water_supply(water_systems_path, registry_path, irrigation_demand_df, *,
                     water_policy_path=None, water_system_name='main_irrigation',
                     root_dir=None)
save_water_supply(df, output_dir, *, filename='daily_water_supply.csv', decimals=3)
load_water_supply(path)
```

`irrigation_demand_df` is the DataFrame produced by `src/irrigation_demand.py`
(`compute_irrigation_demand`), providing `total_demand_m3` and `crop_tds_requirement_ppm` per day.

### Simulation Loop

`compute_water_supply` calls `_run_simulation`, which iterates over each row of `irrigation_demand_df`
in date order, passing the mutable `tank_state = {'fill_m3': ..., 'tds_ppm': ...}` dict forward
between calls to `_dispatch_day`. This is the only stateful part — all other helpers are pure
functions.

### Key Logic in `_dispatch_day`

1. Determine today's demand and TDS target
2. Check if tank can supply part or all of demand (limited by max output rate and fill level);
   draw from tank first if `tds_ppm <= tds_req`
3. Determine remaining demand after storage draw
4. Compute groundwater allowance (look-ahead or cumulative cap check per well)
5. Decide blend ratio: fraction to treat vs pass untreated, to hit TDS target
6. Compute treatment reject volume; subtract from available
7. If blended groundwater still insufficient or TDS too high, supplement with municipal
   (subject to municipal cap)
8. Compute pumping energy for each well draw
9. Compute treatment energy
10. Compute blended TDS of final delivery stream
11. Record deficit if total delivered < demand
12. Refill storage tank with any surplus (not implemented in v1 — deliver exactly demand)
13. Update tank state (volume-weighted TDS mixing) with water added this day

### Assumptions

- Groundwater TDS does not change over the simulation (static from well config)
- Building demand is 100% supplied from municipal water (outside the scope of this module)
- Municipal water TDS is always lower than all groundwater sources
- Untreated groundwater is always cheaper per m3 than municipal
- Treated groundwater may be cheaper than municipal at amortized O&M rates (no CAPEX in daily cost)
- Well draw is split equally across all active wells (v1); weighted dispatch is a future extension
- Storage receives water only when daily supply exceeds demand (v1 does not pre-fill)
