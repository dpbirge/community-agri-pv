# Water System Specification

---

## Implementation Status

### Complete

**Data files** (`data/water/`):

- `wells-toy.csv` — 38 rows, depths 10–120m, TDS 1000–8000 ppm, flow rates, capital + O&M costs
- `pump_systems-toy.csv` — 5 pump types with depth, flow rate, efficiency, motor kW, costs
- `treatment_kwh_per_m3-toy.csv` — 7 TDS bands, energy min/typical/max, recovery rate, brine ratio
- `water_treatment-research.csv` — 12 TDS bands, energy, recovery, membrane life, CAPEX/OPEX
- `storage_systems-toy.csv` — 3 types (underground tank, surface tank, reservoir), evaporation, costs
- `irrigation_systems-toy.csv` — 3 types (drip, sprinkler, furrow), efficiency, costs

**Configuration files** (`settings/`):

- `water_systems_base.yaml` — 3 wells, BWRO treatment unit, municipal source, underground storage tank
- `water_policy_base.yaml` — irrigation mode (static/dynamic), dispatch strategy, monthly caps
- `data_registry_base.yaml` — `water_supply` and `water_pricing` sections registered

**Source modules** (`src/`):

- `src/irrigation_demand.py` — fully implemented; reads farm profiles + crop growth data; outputs
  per-field ETc, demand (m3/day), and crop TDS requirements; public API: `compute_irrigation_demand`,
  `save_irrigation_demand`, `load_irrigation_demand`
- `src/crop_yield.py` — fully implemented; FAO Paper 33 water-yield response for post-simulation
  harvest prediction; used in dynamic irrigation mode

**Simulation outputs** (`simulation/`):

- `daily_irrigation_demand.csv` — generated by `src/irrigation_demand.py`; columns: day,
  per-field ETc, per-field demand (m3), per-field crop, total demand (m3), TDS requirement (ppm)

### Not Yet Implemented

- **`src/water.py`** — the core water system simulation module (see next section)

---

## System Configuration Structure

The system uses `water_systems.yaml` to define one or more independent water systems. Each system contains:

- **N wells** — each with depth (m), pump type, flow rate (m3/hr), and TDS (ppm)
- **One treatment unit** — type (BWRO), throughput (m3/hr), goal output TDS (ppm); energy looked up
  by snapping input TDS to the nearest band in the treatment CSV
- **One municipal source** — cost (per m3), monthly cap (m3, optional), TDS (ppm, ~200), throughput (m3/hr)
- **Zero or one storage tank** — capacity (m3), type, max output rate (m3/hr); initial fill and TDS
  read from config

Water quality is tracked as TDS (ppm) — the single scalar quality metric.

---

## Water Flow & Blending

- Untreated well water goes directly to fields when its TDS is at or below the day's crop requirement
- Treated and untreated groundwater can be blended to hit a TDS target more cheaply than full treatment
- Three-way blending: untreated groundwater + treated groundwater + municipal water
- Treatment produces brine/reject water — tracked as lost volume, not delivered to fields
- Blended TDS is the volume-weighted average of all contributing streams

---

## Storage Tank Behavior

- Tank carries two state variables across days: fill level (m3) and blended TDS (ppm)
- When mixed-quality water enters, blended TDS is recalculated via volume-weighted mixing
- Tank state is initialized from `water_systems.yaml` (initial fill + initial TDS)
- Tank draw is limited by `max_output_rate` (m3/hr × 24 hr/day); input is limited only by sources

---

## Daily TDS Requirement

- Requirement is the minimum (strictest) `tds_no_penalty_ppm` threshold across all crops active on
  that day across all fields linked to the water system
- Three threshold levels exist in `crop_growth_params-research.csv`:
  - `tds_no_penalty_ppm` — below this, no yield reduction
  - `tds_upper_stress_ppm` — between lower and upper, yield reduces
  - `tds_lethal_ppm` — above this, crop dies
- The simulation targets `tds_no_penalty_ppm` to avoid any yield penalty; upper-stress and lethal
  thresholds are available for future stress-response extensions

---

## Pumping Energy

Formula (SI units, result in kWh):

```text
pumping_energy_kwh = (1000 × 9.81 × depth_m × volume_m3) / (pump_efficiency × 3_600_000)
```

Where 1000 kg/m³ is water density, 9.81 m/s² is gravitational acceleration, and 3,600,000 converts
joules to kWh. Use well depth as the primary head; horizontal losses are secondary and omitted for
now.

## Treatment Energy

Snap the blended input TDS to the nearest row in the treatment CSV. Use the `energy_kwh_per_m3`
(or `typical` column in the toy CSV) multiplied by treated volume to get `treatment_energy_kwh`.
Track brine volume as:

```text
brine_m3 = treated_volume_m3 × (1 - recovery_rate_pct / 100)
```

---

## Policy & Dispatch

Policy is configured in `water_policy_base.yaml`. The MVP uses rule-based priority dispatch.
Three strategies are selectable via `blending_strategy`:

- `minimize_cost` — minimize the total cost of water delivered (default)
- `minimize_treatment` — minimize volume sent through treatment (prefers direct draw + municipal)
- `minimize_draw` — minimize total groundwater extraction (prefers municipal up to cap)

### Monthly Cap Enforcement

- `look_ahead: true` (the current default) — remaining monthly cap divided evenly across the
  remaining days of the month; this daily allowance replaces the cap floor on each day
- `look_ahead: false` — enforce only a running cumulative cap (simpler, can front-load consumption)

---

## Daily Output Columns

The output DataFrame from `src/water.py` must include:

| Column | Description |
| --- | --- |
| `day` | date |
| `{well_name}_extraction_m3` | m3 drawn from each well (one col per well) |
| `{well_name}_tds_ppm` | TDS of each well (static from config) |
| `total_groundwater_m3` | total extracted across all wells |
| `treated_volume_m3` | volume sent through treatment |
| `treatment_reject_m3` | brine/reject volume lost |
| `treatment_energy_kwh` | energy consumed by treatment |
| `pumping_energy_kwh` | energy consumed by all pumps |
| `municipal_volume_m3` | municipal water used |
| `municipal_cost` | cost of municipal water |
| `groundwater_cost` | pumping + treatment cost (amortized O&M, not CAPEX) |
| `total_water_cost` | municipal + groundwater cost |
| `blended_tds_delivered_ppm` | TDS of water actually delivered to fields |
| `crop_tds_requirement_ppm` | required TDS threshold for the day (from irrigation demand) |
| `total_delivered_m3` | total water delivered to fields |
| `deficit_m3` | unmet demand when caps prevent full delivery |
| `storage_level_m3` | tank fill level at end of day |
| `storage_tds_ppm` | tank TDS at end of day |
| `total_energy_kwh` | pumping + treatment combined |

---

## Next Steps: `src/water.py`

This is the sole remaining deliverable. It follows the same functional architecture as
`src/energy_supply.py` and `src/community_demand.py`.

### Module-level API

```python
compute_water_supply(water_systems_path, registry_path, irrigation_demand_df, *,
                     water_policy_path=None, water_system_name='main_irrigation',
                     root_dir=None)
save_water_supply(df, output_dir, *, filename='daily_water_supply.csv', decimals=3)
load_water_supply(path)
```

`irrigation_demand_df` is the DataFrame produced by `src/irrigation_demand.py`
(`compute_irrigation_demand`), providing `total_demand_m3` and `crop_tds_requirement_ppm` per day.

### Internal Helpers

```text
_load_yaml(path)
_load_well_specs(wells_path, pump_path, system_config)
    → list of well dicts: {name, depth_m, tds_ppm, flow_rate_m3_day, pump_efficiency, ...}
_load_treatment_lookup(treatment_path)
    → DataFrame keyed on TDS band with energy and recovery columns
_snap_tds_to_band(input_tds, treatment_df)
    → row from treatment_df for the nearest TDS band
_pumping_energy_kwh(volume_m3, depth_m, pump_efficiency)
    → float
_blend_tds(volumes, tds_values)
    → volume-weighted average TDS (float)
_look_ahead_allowance(day, monthly_cap, used_this_month, days_in_month)
    → max m3 available today under look-ahead spreading
_dispatch_day(demand_m3, tds_req, wells, treatment_df, municipal, tank_state, policy)
    → dict of all output column values for one day, plus updated tank_state
_run_simulation(days, demand_df, wells, treatment_df, municipal, tank_state, policy, caps)
    → DataFrame of all daily output columns
```

### Simulation Loop

`compute_water_supply` calls `_run_simulation`, which iterates over each row of `irrigation_demand_df`
in date order, passing the mutable `tank_state = {'fill_m3': ..., 'tds_ppm': ...}` dict forward
between calls to `_dispatch_day`. This is the only stateful part — all other helpers are pure
functions.

### Key Logic in `_dispatch_day`

1. Determine today's demand and TDS target
2. Check if tank can supply part or all of demand (limited by max output rate and fill level);
   draw from tank first if `tds_ppm ≤ tds_req`
3. Determine remaining demand after storage draw
4. Compute groundwater allowance (look-ahead or cumulative cap check per well)
5. Decide blend ratio: fraction to treat vs pass untreated, to hit TDS target
6. Compute treatment reject volume; subtract from available
7. If blended groundwater still insufficient or TDS too high, supplement with municipal
   (subject to municipal cap)
8. Compute pumping energy for each well draw
9. Compute treatment energy
10. Compute blended TDS of final delivery stream
11. Record deficit if total delivered < demand
12. Refill storage tank with any surplus (not implemented in MVP — deliver exactly demand)
13. Update tank state (volume-weighted TDS mixing) with water added this day

### Assumptions

- Groundwater TDS does not change over the simulation (static from well config)
- Building demand is 100% supplied from municipal water (outside the scope of this module)
- Municipal water TDS is always lower than all groundwater sources
- Untreated groundwater is always cheaper per m3 than municipal
- Treated groundwater may be cheaper than municipal at amortized O&M rates (no CAPEX in daily cost)
- Well draw is split equally across all active wells (v1); weighted dispatch is a future extension
- Storage receives water only when daily supply exceeds demand (v1 does not pre-fill)

### Files to Touch

| File | Action |
| --- | --- |
| `src/water.py` | Create — the full simulation module |
| `settings/data_registry_base.yaml` | Verify `water_pricing.agricultural_bulk_toy` path is correct |
| `data/prices/water/` | Confirm municipal pricing CSV exists at the registered path |
